Voici un **quiz exhaustif sur SharedPreferences dans Flutter**, au format examen national. Il couvre tous les aspects fondamentaux et avancÃ©s : initialisation, lecture/Ã©criture, types supportÃ©s, sÃ©rialisation, architecture (Provider, singleton), sÃ©curitÃ© et bonnes pratiques.

Chaque question est suivie de **4 choix (A, B, C, D)** et d'une **rÃ©ponse dÃ©taillÃ©e**.

---

# ğŸ“ **Quiz Flutter â€“ SharedPreferences**

---

### **Question 1**

**Pourquoi la mÃ©thode `SharedPreferences.getInstance()` est-elle `async` ?**

* A. Car elle lit depuis un fichier local en JSON
* B. Car elle nÃ©cessite une connexion Internet
* C. Car elle accÃ¨de Ã  une ressource I/O de maniÃ¨re asynchrone
* D. Car elle crÃ©e un nouvel objet Ã  chaque appel

**RÃ©ponse : C**

> La mÃ©thode est `async` car elle effectue un accÃ¨s I/O (stockage local persistent). Flutter utilise `Future` pour Ã©viter de bloquer le thread principal.

---

### **Question 2**

**Quelle est la valeur par dÃ©faut retournÃ©e par `prefs.getInt('counter')` si la clÃ© n'existe pas ?**

* A. 0
* B. null
* C. -1
* D. Une exception est levÃ©e

**RÃ©ponse : B**

> Si la clÃ© nâ€™existe pas, `getInt()` renvoie `null`. Il est donc courant dâ€™utiliser `prefs.getInt('counter') ?? 0`.

---

### **Question 3**

**Laquelle des mÃ©thodes suivantes est incorrecte avec SharedPreferences ?**

* A. `prefs.setStringList()`
* B. `prefs.setDouble()`
* C. `prefs.setMap()`
* D. `prefs.setBool()`

**RÃ©ponse : C**

> SharedPreferences **ne supporte pas directement les Map**. Il faut les sÃ©rialiser manuellement en JSON (`Map -> String`).

---

### **Question 4**

**Comment stocker un objet complexe avec SharedPreferences ?**

* A. En utilisant `prefs.setObject()`
* B. En l'encodant avec `jsonEncode()` et en le stockant en `String`
* C. En utilisant `prefs.setMap()`
* D. En utilisant `prefs.setDynamic()`

**RÃ©ponse : B**

> Les objets complexes doivent Ãªtre encodÃ©s avec `jsonEncode()` avant dâ€™Ãªtre stockÃ©s sous forme de chaÃ®ne avec `setString()`.

---

### **Question 5**

**Quel type n'est **pas** nativement pris en charge par SharedPreferences ?**

* A. int
* B. double
* C. bool
* D. List<int>

**RÃ©ponse : D**

> Seules les `List<String>` sont supportÃ©es nativement. Les autres types de liste comme `List<int>` ne sont pas acceptÃ©s.

---

### **Question 6**

**Quelle instruction efface toutes les donnÃ©es stockÃ©es dans SharedPreferences ?**

* A. `prefs.removeAll()`
* B. `prefs.clear()`
* C. `prefs.flush()`
* D. `prefs.reset()`

**RÃ©ponse : B**

> `prefs.clear()` supprime toutes les clÃ©s et toutes les valeurs enregistrÃ©es.

---

### **Question 7**

**Pourquoi appelle-t-on `WidgetsFlutterBinding.ensureInitialized()` avant `runApp()` ?**

* A. Pour initialiser les dÃ©pendances
* B. Pour permettre lâ€™utilisation de mÃ©thodes `async` avant le lancement de lâ€™app
* C. Pour activer le `MaterialApp`
* D. Pour charger les assets

**RÃ©ponse : B**

> Cette mÃ©thode est nÃ©cessaire si on exÃ©cute du code asynchrone (comme `await SharedPreferences.getInstance()`) **avant** d'appeler `runApp()`.

---

### **Question 8**

**La mÃ©thode suivante est-elle correcte ?**

```dart
await prefs.setStringList('cities', ['Paris', 'Tunis']);
```

* A. Oui
* B. Non, SharedPreferences ne supporte pas de liste
* C. Non, il faut sÃ©rialiser manuellement la liste
* D. Non, seules les maps sont autorisÃ©es

**RÃ©ponse : A**

> `setStringList()` est une mÃ©thode valide. Les listes de chaÃ®nes sont **le seul type de liste autorisÃ© nativement**.

---

### **Question 9**

**Que renvoie `prefs.getString('username')` si la clÃ© nâ€™a jamais Ã©tÃ© Ã©crite ?**

* A. La chaÃ®ne vide `""`
* B. `null`
* C. Une erreur
* D. `undefined`

**RÃ©ponse : B**

> Si la clÃ© nâ€™existe pas, `getString()` renvoie `null`.

---

### **Question 10**

**Quel est lâ€™intÃ©rÃªt dâ€™utiliser un `FutureBuilder` pour lire des prÃ©fÃ©rences ?**

* A. Il permet dâ€™ajouter des animations
* B. Il permet de gÃ©rer la lecture `Future` de faÃ§on dÃ©clarative
* C. Il remplace `SharedPreferences.getInstance()`
* D. Il rend la lecture synchrone

**RÃ©ponse : B**

> `FutureBuilder` permet de construire dynamiquement un widget **en fonction de lâ€™Ã©tat dâ€™un `Future`**.

---

### **Question 11**

**Laquelle de ces mÃ©thodes est valide pour supprimer une clÃ© ?**

* A. `prefs.clearKey('key')`
* B. `prefs.remove('key')`
* C. `prefs.delete('key')`
* D. `prefs.drop('key')`

**RÃ©ponse : B**

> `prefs.remove()` est la mÃ©thode officielle pour supprimer **une seule** clÃ©.

---

### **Question 12**

**Pourquoi utilise-t-on souvent un singleton pour encapsuler `SharedPreferences` ?**

* A. Pour gagner en performance et Ã©viter de rÃ©pÃ©ter `getInstance()`
* B. Pour avoir plusieurs instances indÃ©pendantes
* C. Pour rendre lâ€™objet observable
* D. Pour simplifier le test unitaire uniquement

**RÃ©ponse : A**

> Cela centralise lâ€™accÃ¨s et Ã©vite de dupliquer `SharedPreferences.getInstance()` dans plusieurs fichiers.

---

### **Question 13**

**Quelle classe faut-il utiliser pour permettre la persistance dans une architecture Provider ?**

* A. `StreamController`
* B. `SettingsManager`
* C. `ChangeNotifier`
* D. `BlocBuilder`

**RÃ©ponse : C**

> `ChangeNotifier` permet de notifier la vue quâ€™un changement a eu lieu aprÃ¨s la mise Ã  jour des prÃ©fÃ©rences.

---

### **Question 14**

**Ã€ quel moment doit-on appeler `notifyListeners()` dans un Provider ?**

* A. AprÃ¨s avoir Ã©crit dans SharedPreferences
* B. Avant dâ€™Ã©crire
* C. Jamais
* D. Seulement au premier chargement

**RÃ©ponse : A**

> Cela signale Ã  tous les widgets consommateurs que lâ€™Ã©tat a changÃ©.

---

### **Question 15**

**Quelle est la bonne sÃ©quence dans un Provider lors dâ€™un `toggleDarkMode()` ?**

* A. Modifier variable, Ã©crire dans prefs, `notifyListeners()`
* B. `notifyListeners()`, modifier variable, Ã©crire prefs
* C. Ã©crire dans prefs uniquement
* D. Modifier variable uniquement

**RÃ©ponse : A**

> On modifie lâ€™Ã©tat, on le persiste, puis on notifie la vue.

---

### **Question 16**

**Quel est le rÃ´le de `prefs.containsKey('username')` ?**

* A. Supprimer une clÃ©
* B. Ã‰crire une valeur
* C. VÃ©rifier si une clÃ© existe
* D. RÃ©initialiser une valeur

**RÃ©ponse : C**

> `containsKey()` retourne un boolÃ©en indiquant si une certaine clÃ© est prÃ©sente dans la base.

---

### **Question 17**

**Laquelle des affirmations suivantes est correcte ?**

* A. `SharedPreferences` est synchrone
* B. Les prÃ©fÃ©rences sont stockÃ©es dans la RAM
* C. `SharedPreferences` utilise une base de donnÃ©es SQLite
* D. Les prÃ©fÃ©rences sont stockÃ©es dans le stockage local persistant

**RÃ©ponse : D**

> Les prÃ©fÃ©rences sont stockÃ©es localement, **dans un fichier XML (Android)** ou **NSUserDefaults (iOS)**.

---

### **Question 18**

**Quelle est la mÃ©thode recommandÃ©e pour tester une mÃ©thode utilisant SharedPreferences ?**

* A. Utiliser `Mockito` et mocker `SharedPreferences`
* B. Utiliser `runApp()` directement
* C. Utiliser un `FutureBuilder` dans les tests
* D. Tester dans `main()`

**RÃ©ponse : A**

> Il est recommandÃ© de **faker ou mocker** lâ€™instance `SharedPreferences` pour ne pas Ã©crire dans la vraie base pendant les tests.

---

### **Question 19**

**Le contenu de SharedPreferences est-il conservÃ© aprÃ¨s redÃ©marrage de lâ€™application ?**

* A. Non
* B. Oui, sauf si on utilise Flutter Web
* C. Oui
* D. Uniquement si on utilise `save()`

**RÃ©ponse : C**

> Oui, câ€™est **le but de SharedPreferences** : persister les donnÃ©es entre plusieurs exÃ©cutions.

---

### **Question 20**

**Quelle est la taille maximale recommandÃ©e dâ€™un objet stockÃ© dans SharedPreferences ?**

* A. 512 Ko
* B. 1 Mo
* C. 100 Ko
* D. 10 Mo

**RÃ©ponse : C**

> Il est conseillÃ© de **ne pas dÃ©passer 100 Ko**, au risque de ralentir le chargement et dâ€™avoir des erreurs.

---

Souhaitez-vous que je vous fournisse **les 10 derniÃ¨res questions** pour complÃ©ter un quiz de **30 questions** ? Ou bien souhaitez-vous un **format imprimable en `.docx`** ou `.md` pour cours ou examen ?
